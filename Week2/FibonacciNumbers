Fibonacci Numbers 1:

F(n) = {  0, if n=0
	1, if n=1,
	F(n-1) + F(n-2), if n>1.
      }


Rapid growth:
Prove (Lemma) : 
F(n) >= 2^(n/2) for n>=6

Proof by induction:
Base case n=6,7 (by direct computation).
Inductive step:
F(n) 	= F(n-1) + F(n-2)
	>= 2^((n-1)/2) + 2^((n-2)/2)
	>= 2.2^((n-2)/2)
	= 2^(n/2)

Formula for nth Fibonaci number:
F(n) = {1/sq(5)}.{[(1+sq(5))/2]^n - [(1-sq(5))/2]^n}
F(20) = 6765
F(50) = 12 billion
F(500) = blah blah blah

Compute F(n)
Input: Any integer n>=0
Output: F(n)

1) Naive Algorithm:
FibRecurs(s)
if n<=1:
	return n
else:
	return FibRecus(n-1) + FibRecurs(n-2)

Running Time:
Let T(n) denote  the number of lines of code executed by Algo on input n.
if n=1, T(n)=2
if n=2, T(n)=3 + T(n-1) + T(n-2)
Here, 
T(n) = { 2 if n<=1
	T(n-1) + T(n-2) + 3 else
	}
Therefore, T(n) >= F(n)
T(100) == 1.77.10^(21)
Still it would take 56000 years at 1GHz.

Why so slow?
It is because of lot lot lot of recursive calls.
Big tree of recursive calls.
If we look at the tree, we are computing a particular entry multiple times!!!
Computing same thing over and over again.
If the tree is again increased, the inteties are being calculated more and more times.

2) ANOTHER ALGORITHM
Initiate hand computation:
0,1,1
FibList(n)
create an array F[0...n]
F[0]<- 0
F[1]<- 1
for i from 2 to n:
	F[i] <- F[i-1] + F[i-2]
return F[n]

How fast is it?
T(n) = 2n+2 So T(100) = 202
Very easy to compute.
This improved algorithm is incredibly fast.

The right algo makes all the difference.

