QuickSort

Overview:
-> Comparisoin based algorithm
-> Running time: O(nlogn) (on average)
-> efficient in practice.

Quick Sort Toy example:
[6 4 8 2 9 3 9 4 7 6 1]
Select 6, now we want all elements <= 6, to be before 6, and all elements >= 6 to be after 6.
We rearrange the array that way now.

Partition with respect to x = A[1]
in particular, x is in it's final position.

[1 4 2 3 4 6| 6 9 7 8 9]
    <=6           >6
Now, 6 is not in it's final position.
Now what we need to do is to sort all the elements before 6, and all the elements after 6.
Now, we do this by the same recursive call to quick sort algorithm.

sort the two parts recursively.
[1 2 3 4 4 6 6 7 8 9 9]



Algorithm:
QuickSort(A,l,r)
if l>r:
    return
m <- Partition(A,l,r)
{A[m] is in the final position}
QuickSort(A,l, m-1)
QuickSort(A,m+1, r)


Now:
  l                r
A[                 ]

    m <- Partition(A,l,r)

A[       <=x       |x|        >x       ]
  QuickSort(A,l,m-1)  QuickSort(A,m+1,r)

A[        |x|        ]
Sorted.


Partitioning: example:
The pivot is x = A[l]
move i from l+1 to r, maintaining the following invariant.
    -> A[k] <= x for all l+1 <= k <= j
    -> A[k] > x for all j+1 <= k <= i

Let's see an example for this:
l                    r
[6 4 2 3 9 8 9 4 7 6 1]
   j i
Now, start with i,
Now, 2 < 6, so we need to increase the value of j, as well as i.

l                    r
[6 4 2 3 9 8 9 4 7 6 1]
     j i
Now, Again, 3<6, so we need to increase j region. Incerease j as well as i.

l                    r
[6 4 2 3 9 8 9 4 7 6 1]
       j i
Now is interesting case, 9>6. So we need to increase the i region.

l                    r
[6 4 2 3 9 8 9 4 7 6 1]
       j   i
Now, 8>6, again increase the i region.

l                    r
[6 4 2 3 9 8 9 4 7 6 1]
       j     i
9>6, increase i region.

l                    r
[6 4 2 3 9 8 9 4 7 6 1]
       j       i
Now, interesting case. 4<6, so we need to incease j region. we need to increase value of j, and then swap value of j and i, then increase the value of i.

l                    r
[6 4 2 3 4 8 9 9 7 6 1]
         j       i
Now, 7>6, increase value of i.

l                    r
[6 4 2 3 4 8 9 9 7 6 1]
         j         i
6<=6, so we again increase value of j, swap value of j and i, then increase value of i.

l                    r
[6 4 2 3 4 6 9 9 7 8 1]
           j         i
Now, 1<6, repeat the above process.

l                    r
[6 4 2 3 4 6 1 9 7 8 9]
             j        i
Now, since value of i>r, we now want to place the pivot in it's final place.
i.e. Place A[l] in final place.
Now, swap A[l] with A[j].

l                    r
[1 4 2 3 4 6 |6| 9 7 8 9]
This is the final array after one complete cycle.


Partition(A,l,r)
x <- A[l] {pivot}
j <- l
for i from l+1 to r:
    if A[i] <= x:
        j <- j + 1
        swap A[j] and A[i]
        {A[l+1...j] <= x, A[j+1....i] > x}
swap A[l] and A[j]
return j



Random Pivet:
Unbalanced Partitions:
T(n) = n + T(n-1)
We can expand T(n-1) = n-1 + T(n-2)
T(n) = n + (n-1) + (n-2) + ... = O(n^2)

Now different case:
T(n) = n + T(n-5) + T(4)
T(n) >= n + (n-5) + (n-10) + .... = O(n^2)


Balanced Partitoins:
T(n) = 2T(n/2) + n
Then T(n) = O(nlogn), we know this recurrance already.

Differenct case:
T(n) = T(n/10) + T(9n/10) + n;
    T(n) = O(nlogn)


Random Pivot Pusedo code.
RandomizedQuickSort(A,l,r):
if l >= r:
    return
k <- random number between l and r
swap A[l] and A[k]
m <- Partition(A,l,r)
{A[m] is in the final position}
RandomizedQuickSort(A,l,m-1)
RandomizedQuickSort(A,m+1,r)


Why Random?
Half of the elements of A guarantees a balanced partition:


Theorem:
Assume that all elements of A[1....n] are pairwise different. 
Then the average running time of RandomizedQuickSort(A) is O(nlogn) while the worst case running time is O(n^2).

Remark:
Averaging is over random numbers used by the algorithm, but not over the inputs.



Running time:

Proof Ideas: Comparisons
-> The running time is proportional to the number of comparisons made.
-> Balanced partition are better since they reduce the number of comparisons needed:

Proof Ideas: Probability
A [5 1 8 9 2 4 7 3 6]
A' [1 2 3 4 5 6 7 8 9]
Prob(1 and 9 are compared) = 2/9 [depends on how close they are in the sorted array]
Prob(3 and 4 are compared) = 1

Proof:
let, for i<j
X[ij] = {
    1 if A'[i] and A'[j] are compared.
    0 otherwise
}

For all i<j, A'[i] and A'[j] are eihter compared exactly once or not compared at all (as we compare with a pivot)
This, in particular, implies that the worst cae running time is O(n^2)

crucial observation: X[ij] = 1 iff the first selected pivot in A'[i....j] is A'[i] or A'[j]

Then Prob(X[ij]) = 2/(j-i+1) and 
E(X[ij]) = 2/(j-i+1)
Since X[ij] is eihter 0 or 1, E(X[ij]) = 0*(Prob(0)) + 1*Prob(1)
                                        = 2/(j-1+1)
Then(then expeted value of) the running time
E(X[ij]) where i=1 to n, j=i+1 to n
                = sum of all i,j E(X[ij])
                = sum of all i<j (2/(j-i+1))
                <= 2n.(1/2 + 1/3 + ... + 1/n) [We have a harmonic series here.]
                = O(nlogn)



Equal Elements:
What if all the elements of the given array are equal to each other?
Quick sort is not so fast when it comes to equal elements.
the array is always split in two parts of size 0 and n-1.
T(n) = n + T(n-1) + T(0)
and hence
T(n) = O(n^2)



Overcome Equal elements, we replace the following:
m <- Partition(A,l,r)
with the line
(m1,m2) <- Partition3(A,l,r)
We do three way partition
such that:
-> For all l <= k <= m1 -1 , A[k] < x
-> For all m1 <= k <= m2, A[k]=X
-> For all m1+1 <= k <= r, A[k]>x
l                           r
[                           ]

l                           r
[   <x  |      =x      |     >x    ]
       m1              m2

RandomizedQuikcSort(A,l,r)
if l>r:
    return
k <- random number between l and r
swap A[l] and A[k]
(m1,m2) <- Partitions3(A,l,r)
{A[m1....m2] is in final position}
RandomizedQuickSort(A,l,m1-1)
RandomizedQuickSort(A,m2+1,r)



Final Remarks:
Tail Recursion Elimination
QuickSort(A,l,r)
while l<r:
    m <- Partition(A,l,r)
    if (m-l) < (r-m)
        QuickSort(A,l,m-1)
        l <- m+1
    else:
        QuickSort(A,m+1,r)
        r <- m-1



Intro Sort:
-> Run quick sort with a simple deterministic pivot selection heuristic
-> say, median of the first, middle, and last element.
-> if the recursion depth exceeds a certion threshold clogn, the algorithm switches to heap sort.
-> The running time is O(nlogn) in the worst case.


Conclusion:
-> Quick sort is a comparison based algorithm.
-> Running time: O(nlogn) on average, O(n*2) in the worst case.
-> Efficient in practice.

